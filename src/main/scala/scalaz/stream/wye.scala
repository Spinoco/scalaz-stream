package scalaz.stream

import collection.immutable.Queue
import concurrent.duration._

import scalaz.{\/, -\/, \/-}
import scalaz.\/._
import Process._
import These.{This,That}

trait wye {

  import scalaz.stream.wye.{AwaitL, AwaitR, AwaitBoth}
  /**
   * A `Wye` which emits values from its right branch, but allows up to `n`
   * elements from the left branch to enqueue unanswered before blocking
   * on the right branch.
   */
  def boundedQueue[I](n: Int): Wye[Any,I,I] =
    yipWithL(n)((i,i2) => i2)

  /**
   * After each input, dynamically determine whether to read from the left, right, or both,
   * for the subsequent input, using the provided functions `f` and `g`. The returned
   * `Wye` begins by reading from the left side and is left-biased--if a read of both branches
   * returns a `These(x,y)`, it uses the signal generated by `f` for its next step.
   */
  def dynamic[I,I2](f: I => wye.Request, g: I2 => wye.Request): Wye[I,I2,These[I,I2]] = {
    import wye.Request._
    def go(signal: wye.Request): Wye[I,I2,These[I,I2]] = signal match {
      case L => awaitL[I].flatMap { i => emit(This(i)) fby go(f(i)) }
      case R => awaitR[I2].flatMap { i2 => emit(That(i2)) fby go(g(i2)) }
      case Both => awaitBoth[I,I2].flatMap {
        case t@This(i) => emit(t) fby go(f(i))
        case t@That(i2) => emit(t) fby go(g(i2))
        case t@These(i,_) => emit(t) fby go(f(i)) // left-biased
      }
    }
    go(L)
  }

  /**
   * A `Wye` which echoes the right branch while draining the left,
   * taking care to make sure that the left branch is never more
   * than `maxUnacknowledged` behind the right. For example:
   * `src.connect(snk)(observe(10))` will output the the same thing
   * as `src`, but will as a side effect direct output to `snk`,
   * blocking on `snk` if more than 10 elements have enqueued
   * without a response.
   */
  def drainL[I](maxUnacknowledged: Int): Wye[Any,I,I] =
    wye.flip(drainR(maxUnacknowledged))

  /**
   * A `Wye` which echoes the left branch while draining the right,
   * taking care to make sure that the right branch is never more
   * than `maxUnacknowledged` behind the left. For example:
   * `src.connect(snk)(observe(10))` will output the the same thing
   * as `src`, but will as a side effect direct output to `snk`,
   * blocking on `snk` if more than 10 elements have enqueued
   * without a response.
   */
  def drainR[I](maxUnacknowledged: Int): Wye[I,Any,I] =
    yipWithL[I,Any,I](maxUnacknowledged)((i,i2) => i)

  /**
   * Invokes `dynamic` with `I == I2`, and produces a single `I` output. Output is
   * left-biased: if a `These(i1,i2)` is emitted, this is translated to an
   * `emitSeq(List(i1,i2))`.
   */
  def dynamic1[I](f: I => wye.Request): Wye[I,I,I] =
    dynamic(f, f).flatMap {
      case This(i) => emit(i)
      case That(i) => emit(i)
      case These(i1,i2) => emitSeq(List(i2,i2))
    }

  /**
   * Nondeterminstic interleave of both inputs. Emits values whenever either
   * of the inputs is available.
   */
  def either[I,I2]: Wye[I,I2,I \/ I2] =
    merge[I \/ I2].contramapL((i: I) => left(i)).
                   contramapR((i2: I2) => right(i2))

  /**
   * Let through the right branch as long as the left branch is `false`,
   * listening asynchronously for the left branch to become `true`.
   * This halts as soon as the right branch halts.
   */
  def interrupt[I]: Wye[Boolean, I, I] = {
    def go[I]: Wye[Boolean, Option[I], I] = awaitBoth[Boolean,Option[I]].flatMap {
      case That(None) => halt
      case That(Some(i)) => emit(i) ++ go
      case This(kill) => if (kill) halt else go
      case These(kill, Some(i)) => if (kill) halt else emit(i) ++ go
      case These(kill, None) => halt
    }
    wye.attachR(process1.terminated[I])(go[I])
  }

  /**
   * Nondeterminstic interleave of both inputs. Emits values whenever either
   * of the inputs is available.
   */
  def merge[I]: Wye[I,I,I] = {
    def go(biasL: Boolean): Wye[I,I,I] =
      receiveBoth[I,I,I]({
        case This(i) => emit(i) fby (go(!biasL))
        case That(i) => emit(i) fby (go(!biasL))
        case These(i,i2) =>
          if (biasL) emitSeq(List(i,i2)) fby (go(!biasL))
          else       emitSeq(List(i2,i)) fby (go(!biasL))
      }
    )
    go(true)
  }

  /**
   * A `Wye` which blocks on the right side when either a) the age of the oldest unanswered
   * element from the left size exceeds the given duration, or b) the number of unanswered
   * elements from the left exceeds `maxSize`.
   */
  def timedQueue[I](d: Duration, maxSize: Int = Int.MaxValue): Wye[Duration,I,I] = {
    def go(q: Vector[Duration]): Wye[Duration,I,I] =
      awaitBoth[Duration,I].flatMap {
        case This(d2) =>
          if (q.size >= maxSize || (d2 - q.headOption.getOrElse(d2) > d))
            awaitR[I].flatMap(i => emit(i) fby go(q.drop(1)))
          else
            go(q :+ d2)
        case That(i) => emit(i) fby (go(q.drop(1)))
        case These(t,i) => emit(i) fby (go(q.drop(1) :+ t))
      }
    go(Vector())
  }

  /**
   * `Wye` which repeatedly awaits both branches, emitting any values
   * received from the right. Useful in conjunction with `connect`,
   * for instance `src.connect(snk)(unboundedQueue)`
   */
  def unboundedQueue[I]: Wye[Any,I,I] =
    awaitBoth[Any,I].flatMap {
      case This(any) => halt
      case That(i) => emit(i) fby unboundedQueue
      case These(_,i) => emit(i) fby unboundedQueue
    }

  /** Nondeterministic version of `zip` which requests both sides in parallel. */
  def yip[I,I2]: Wye[I,I2,(I,I2)] = yipWith((_,_))

  /**
   * Left-biased, buffered version of `yip`. Allows up to `n` elements to enqueue on the
   * left unanswered before requiring a response from the right. If buffer is empty,
   * always reads from the left.
   */
  def yipL[I,I2](n: Int): Wye[I,I2,(I,I2)] =
    yipWithL(n)((_,_))

  /** Nondeterministic version of `zipWith` which requests both sides in parallel. */
  def yipWith[I,I2,O](f: (I,I2) => O): Wye[I,I2,O] =
    awaitBoth[I,I2].flatMap {
      case This(i) => awaitR[I2].flatMap(i2 => emit(f(i,i2)))
      case That(i2) => awaitL[I].flatMap(i => emit(f(i,i2)))
      case These(i,i2) => emit(f(i,i2))
    }.repeat

  /**
   * Left-biased, buffered version of `yipWith`. Allows up to `n` elements to enqueue on the
   * left unanswered before requiring a response from the right. If buffer is empty,
   * always reads from the left.
   */
  def yipWithL[I,O,O2](n: Int)(f: (I,O) => O2): Wye[I,O,O2] = {
    def go(buf: Vector[I]): Wye[I,O,O2] =
      if (buf.size > n) awaitR[O].flatMap { o =>
        emit(f(buf.head,o)) ++ go(buf.tail)
      }
      else if (buf.isEmpty) awaitL[I].flatMap { i => go(buf :+ i) }
      else awaitBoth[I,O].flatMap {
        case This(i) => go(buf :+ i)
        case That(o) => emit(f(buf.head,o)) ++ go(buf.tail)
        case These(i,o) => emit(f(buf.head,o)) ++ go(buf :+ i)
      }
    go(Vector())
  }
}

object wye extends wye {

  // combinators that don't have globally unique names and
  // shouldn't be mixed into `processes`

  /**
   * Transform the left input of the given `Wye` using a `Process1`.
   */
  def attachL[I0,I,I2,O](p: Process1[I0,I])(w: Wye[I,I2,O]): Wye[I0,I2,O] = w match {
    case h@Halt(_) => h
    case Emit(h,t) => Emit(h, attachL(p)(t))
    case AwaitL(recv, fb, c) =>
      p match {
        case Emit(h, t) => attachL(t)(wye.feedL(h)(w))
        case Await1(recvp, fbp, cp) =>
          await(L[I0]: Env[I0,I2]#Y[I0])(
            recvp andThen (attachL(_)(w)),
            attachL(fbp)(w),
            attachL(cp)(w))
        case h@Halt(_) => attachL(h)(fb)
      }
    case AwaitR(recv, fb, c) =>
      awaitR[I2].flatMap(recv andThen (attachL(p)(_))).
      orElse(attachL(p)(fb), attachL(p)(c))
    case AwaitBoth(recv, fb, c) =>
      p match {
        case Emit(h, t) => attachL(t)(scalaz.stream.wye.feedL(h)(w))
        case Await1(recvp, fbp, cp) =>
          await(Both[I0,I2]: Env[I0,I2]#Y[These[I0,I2]])(
            { case This(i0) => attachL(p.feed1(i0))(w)
              case That(i2) => attachL(p)(feed1R(i2)(w))
              case These(i0,i2) => attachL(p.feed1(i0))(feed1R(i2)(w))
            },
            attachL(fbp)(w),
            attachL(cp)(w))
        case h@Halt(_) => attachL(h)(fb)
      }
  }

  /**
   * Transform the right input of the given `Wye` using a `Process1`.
   */
  def attachR[I,I1,I2,O](p: Process1[I1,I2])(w: Wye[I,I2,O]): Wye[I,I1,O] =
    flip(attachL(p)(flip(w)))


  /**
   * Feed a single `These` value to a `Wye`.
   */
  def feed1[I,I2,O](i: These[I,I2])(w: Wye[I,I2,O]): Wye[I,I2,O] =
    i match {
      case This(i) => feed1L(i)(w)
      case That(i2) => feed1R(i2)(w)
      case These(i,i2) => feed1Both(i,i2)(w)
    }

  /** Feed a value to both the right and left branch of a `Wye`. */
  def feed1Both[I,I2,O](i: I, i2: I2)(w: Wye[I,I2,O]): Wye[I,I2,O] =
    w match {
      case Halt(_) => w
      case Emit(h, t) => Emit(h, feed1Both(i, i2)(t))
      case AwaitL(recv,fb,c) =>
        try feed1R(i2)(recv(i))
        catch {
          case End => feed1R(i2)(fb)
          case e: Throwable => feed1R(i2)(c.causedBy(e))
        }
      case AwaitR(recv,fb,c) =>
        try feed1L(i)(recv(i2))
        catch {
          case End => feed1L(i)(fb)
          case e: Throwable => feed1L(i)(c.causedBy(e))
        }
      case AwaitBoth(recv,fb,c) =>
        try recv(These(i,i2))
        catch {
          case End => fb
          case e: Throwable => c.causedBy(e)
        }
    }

  /** Feed a single value to the left branch of a `Wye`. */
  def feed1L[I,I2,O](i: I)(w: Wye[I,I2,O]): Wye[I,I2,O] =
    feedL(List(i))(w)

  /** Feed a single value to the right branch of a `Wye`. */
  def feed1R[I,I2,O](i2: I2)(w: Wye[I,I2,O]): Wye[I,I2,O] =
    feedR(List(i2))(w)

  /** Feed a sequence of inputs to the left side of a `Tee`. */
  def feedL[I,I2,O](i: Seq[I])(p: Wye[I,I2,O]): Wye[I,I2,O] = {
    @annotation.tailrec
    def go(in: Seq[I], out: Vector[Seq[O]], cur: Wye[I,I2,O]): Wye[I,I2,O] =
      if (in.nonEmpty) cur match {
        case h@Halt(_) => emitSeq(out.flatten, h)
        case Emit(h, t) => go(in, out :+ h, t)
        case AwaitL(recv, fb, c) =>
          val next =
            try recv(in.head)
            catch {
              case End => fb
              case e: Throwable => c.causedBy(e)
            }
          go(in.tail, out, next)
        case AwaitBoth(recv, fb, c) =>
          val next =
            try recv(These.This(in.head))
            catch {
              case End => fb
              case e: Throwable => c.causedBy(e)
            }
          go(in.tail, out, next)
        case AwaitR(recv, fb, c) =>
          emitSeq(out.flatten,
          await(R[I2]: Env[I,I2]#Y[I2])(recv andThen (feedL(in)), feedL(in)(fb), feedL(in)(c)))
      }
      else emitSeq(out.flatten, cur)
    go(i, Vector(), p)
  }

  /** Feed a sequence of inputs to the right side of a `Tee`. */
  def feedR[I,I2,O](i: Seq[I2])(p: Wye[I,I2,O]): Wye[I,I2,O] = {
    @annotation.tailrec
    def go(in: Seq[I2], out: Vector[Seq[O]], cur: Wye[I,I2,O]): Wye[I,I2,O] =
      if (in.nonEmpty) cur match {
        case h@Halt(_) => emitSeq(out.flatten, h)
        case Emit(h, t) => go(in, out :+ h, t)
        case AwaitR(recv, fb, c) =>
          val next =
            try recv(in.head)
            catch {
              case End => fb
              case e: Throwable => c.causedBy(e)
            }
          go(in.tail, out, next)
        case AwaitBoth(recv, fb, c) =>
          val next =
            try recv(These.That(in.head))
            catch {
              case End => fb
              case e: Throwable => c.causedBy(e)
            }
          go(in.tail, out, next)
        case AwaitL(recv, fb, c) =>
          emitSeq(out.flatten,
          await(L[I]: Env[I,I2]#Y[I])(recv andThen (feedR(in)), feedR(in)(fb), feedR(in)(c)))
      }
      else emitSeq(out.flatten, cur)
    go(i, Vector(), p)
  }

  /**
   * Convert right requests to left requests and vice versa.
   */
  def flip[I,I2,O](w: Wye[I,I2,O]): Wye[I2,I,O] = w match {
    case h@Halt(_) => h
    case Emit(h, t) => Emit(h, flip(t))
    case AwaitL(recv, fb, c) =>
      await(R[I]: Env[I2,I]#Y[I])(recv andThen (flip), flip(fb), flip(c))
    case AwaitR(recv, fb, c) =>
      await(L[I2]: Env[I2,I]#Y[I2])(recv andThen (flip), flip(fb), flip(c))
    case AwaitBoth(recv, fb, c) =>
      await(Both[I2,I])((t: These[I2,I]) => flip(recv(t.flip)), flip(fb), flip(c))
  }

  /**
   * Lift a `Wye` to operate on the left side of an `\/`, passing
   * through any values it receives on the right from either branch.
   */
  def liftL[I0,I,I2,O](w: Wye[I,I2,O]): Wye[I \/ I0, I2 \/ I0, O \/ I0] =
    liftR[I0,I,I2,O](w)
      .map(_.swap)
      .contramapL((e: I \/ I0) => e.swap)
      .contramapR((e: I2 \/ I0) => e.swap)

  /**
   * Lift a `Wye` to operate on the right side of an `\/`, passing
   * through any values it receives on the left from either branch.
   */
  def liftR[I0,I,I2,O](w: Wye[I,I2,O]): Wye[I0 \/ I, I0 \/ I2, I0 \/ O] =
    w match {
      case Emit(h, t) => Emit(h map right, liftR[I0,I,I2,O](t))
      case h@Halt(_) => h
      case AwaitL(recv, fb, c) =>
        val w2: Wye[I0 \/ I, I0 \/ I2, I0 \/ O] =
          awaitL[I0 \/ I].flatMap(_.fold(
            i0 => emit(left(i0)) ++ liftR(w),
            i => liftR[I0,I,I2,O](recv(i))
          ))
        val fb2 = liftR[I0,I,I2,O](fb)
        val c2 = liftR[I0,I,I2,O](c)
        w2.orElse(fb2, c2)
      case AwaitR(recv, fb, c) =>
        val w2: Wye[I0 \/ I, I0 \/ I2, I0 \/ O] =
          awaitR[I0 \/ I2].flatMap(_.fold(
            i0 => emit(left(i0)) ++ liftR(w),
            i => liftR[I0,I,I2,O](recv(i))
          ))
        val fb2 = liftR[I0,I,I2,O](fb)
        val c2 = liftR[I0,I,I2,O](c)
        w2.orElse(fb2, c2)
      case AwaitBoth(recv, fb, c) =>
        val w2: Wye[I0 \/ I, I0 \/ I2, I0 \/ O] = awaitBoth[I0 \/ I, I0 \/ I2].flatMap {
          case This(io) => feed1(This(io))(liftR(AwaitL(recv compose This.apply, fb, c)))
          case That(io) => feed1(That(io))(liftR(AwaitR(recv compose That.apply, fb, c)))
          case These(a,b) =>
            (a, b) match {
              case (-\/(i01), -\/(i02)) => emitSeq(Vector(left(i01), left(i02))) ++ liftR(w)
              case (-\/(i01), \/-(i2)) => emit(left(i01)) ++ liftR(recv(That(i2)))
              case (\/-(i), \/-(i2)) => liftR(recv(These(i,i2)))
              case (\/-(i), -\/(i02)) => emit(left(i02)) ++ liftR(recv(This(i)))
            }
        }
        val fb2 = liftR[I0,I,I2,O](fb)
        val c2 = liftR[I0,I,I2,O](c)
        w2.orElse(fb2, c2)
    }

  /** Simple enumeration for dynamically generated `Wye` request types. See `wye.dynamic`. */
  trait Request
  object Request {
    case object L extends Request
    case object R extends Request
    case object Both extends Request
  }

  object AwaitL {
    def unapply[I,I2,O](self: Wye[I,I2,O]):
        Option[(I => Wye[I,I2,O], Wye[I,I2,O], Wye[I,I2,O])] = self match {
      case Await(req,recv,fb,c) if req.tag == 0 => Some((recv.asInstanceOf[I => Wye[I,I2,O]], fb, c))
      case _ => None
    }
    def apply[I,I2,O](recv: I => Wye[I,I2,O],
                      fallback: Wye[I,I2,O] = halt,
                      cleanup: Wye[I,I2,O] = halt): Wye[I,I2,O] =
      await(L[I]: Env[I,I2]#Y[I])(recv, fallback, cleanup)
  }
  object AwaitR {
    def unapply[I,I2,O](self: Wye[I,I2,O]):
        Option[(I2 => Wye[I,I2,O], Wye[I,I2,O], Wye[I,I2,O])] = self match {
      case Await(req,recv,fb,c) if req.tag == 1 => Some((recv.asInstanceOf[I2 => Wye[I,I2,O]], fb, c))
      case _ => None
    }
    def apply[I,I2,O](recv: I2 => Wye[I,I2,O],
                      fallback: Wye[I,I2,O] = halt,
                      cleanup: Wye[I,I2,O] = halt): Wye[I,I2,O] =
      await(R[I2]: Env[I,I2]#Y[I2])(recv, fallback, cleanup)
  }
  object AwaitBoth {
    def unapply[I,I2,O](self: Wye[I,I2,O]):
        Option[(These[I,I2] => Wye[I,I2,O], Wye[I,I2,O], Wye[I,I2,O])] = self match {
      case Await(req,recv,fb,c) if req.tag == 2 => Some((recv.asInstanceOf[These[I,I2] => Wye[I,I2,O]], fb, c))
      case _ => None
    }
    def apply[I,I2,O](recv: These[I,I2] => Wye[I,I2,O],
                      fallback: Wye[I,I2,O] = halt,
                      cleanup: Wye[I,I2,O] = halt): Wye[I,I2,O] =
      await(Both[I,I2])(recv, fallback, cleanup)
  }
}
